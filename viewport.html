<!DOCTYPE html>
<html>
<head>
  <title>Mist Viewport</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #222;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    #viewport-container {
      width: 100vw;
      height: 100vh;
      overflow: auto;
      background: #222;
      display: flex;
      flex-direction: row;
      align-items: flex-end;
      justify-content: flex-start;
      position: relative;
    }
    .line {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 32px;
      position: relative;
    }
    .line.primary {
      border-left: 4px solid #4fc3f7;
      min-height: 60vh;
      margin-left: 6vw;
      margin-right: 48px;
    }
    .line.category {
      border-bottom: 4px solid #81c784;
      min-width: 24vw;
      margin-bottom: 16vh;
      margin-top: 24px;
    }
    .line.item {
      border-right: 4px solid #ffb74d;
      min-height: 30vh;
      margin-left: 48px;
    }
    .item-box {
      background: #444;
      color: #eee;
      border-radius: 8px;
      margin: 8px 0;
      padding: 8px 16px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      min-width: 120px;
      text-align: center;
      border: 2px solid transparent;
    }
    .item-box.selected {
      background: #eee;
      color: #222;
      border: 2px solid #4fc3f7;
    }
    .input-box {
      margin: 16px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .input-box input, .input-box select {
      padding: 6px 12px;
      margin: 4px 0;
      border-radius: 4px;
      border: 1px solid #888;
      font-size: 1em;
    }
    .input-box button {
      margin-top: 8px;
      padding: 6px 16px;
      border-radius: 4px;
      border: none;
      background: #4fc3f7;
      color: #222;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
    }
    .input-box button:hover {
      background: #0288d1;
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="viewport-container"></div>

  <script>
    // --- State ---
    let state = {
      primaryLine: [],
      categoryLines: {},
      itemLines: {},
      selected: {
        timeIndex: null,
        category: null,
        item: null
      },
      categories: [],
      items: [],
      session: {}
    };

    // --- Initialization ---
    function initViewport() {
      google.script.run.withSuccessHandler(function(data) {
        state.primaryLine = data.primaryLine;
        state.categories = data.categories;
        state.items = data.items;
        renderViewport();
      }).getMistViewportData();
    }

    // --- Rendering ---
    function renderViewport() {
  const container = document.getElementById('viewport-container');
  container.innerHTML = '';

  // Gather lines and their data
  const lines = [];
  lines.push({ type: 'primary', data: state.primaryLine });
  if (state.selected.timeIndex !== null) {
    const time = state.primaryLine[state.selected.timeIndex];
    lines.push({ type: 'category', data: state.categories[time] || [] });
  }
  if (state.selected.category !== null && state.selected.timeIndex !== null) {
    const time = state.primaryLine[state.selected.timeIndex];
    const category = state.categories[time][state.selected.category];
    lines.push({ type: 'item', data: state.items[category] || [] });
  }

  // Render each line at its computed position
  lines.forEach((line, depth) => {
    const lineDiv = document.createElement('div');
    lineDiv.className = 'line ' + line.type;
    line.data.forEach((item, idx) => {
      const box = document.createElement('div');
      box.className = 'item-box' + (
        (depth === 0 && state.selected.timeIndex === idx) ||
        (depth === 1 && state.selected.category === idx) ||
        (depth === 2 && state.selected.item === idx)
        ? ' selected' : ''
      );
      box.textContent = item;
      // Position using hourGlass
      const pos = hourGlass.getPosition(depth, idx);
      box.style.position = 'absolute';
      box.style.left = pos.x + 'px';
      box.style.top = pos.y + 'px';
      // Selection handlers...
      if (depth === 0) box.onclick = () => selectTimeIndex(idx);
      if (depth === 1) box.onclick = () => selectCategory(idx);
      if (depth === 2) box.onclick = () => selectItem(idx);
      lineDiv.appendChild(box);
    });
    container.appendChild(lineDiv);
  });
}

    // --- User Interactions ---
function selectTimeIndex(idx) {
  handleSelection({ type: 'time', index: idx, value: state.primaryLine[idx] });
}
function selectCategory(idx) {
  const time = state.primaryLine[state.selected.timeIndex];
  handleSelection({ type: 'category', index: idx, value: state.categories[time][idx] });
}
function selectItem(idx) {
  const time = state.primaryLine[state.selected.timeIndex];
  const category = state.categories[time][state.selected.category];
  handleSelection({ type: 'item', index: idx, value: state.items[category][idx] });
} 

    function showAddTimeInput() {
      showInputBox('Add Time Index', 'Enter new time index:', function(value) {
        google.script.run.withSuccessHandler(function(newLine) {
          state.primaryLine = newLine;
          renderViewport();
        }).addTimeIndex(value);
      });
    }

    function showAddCategoryInput() {
      const time = state.primaryLine[state.selected.timeIndex];
      showInputBox('Add Category', 'Enter new category:', function(value) {
        google.script.run.withSuccessHandler(function(newCategories) {
          state.categories = newCategories;
          renderViewport();
        }).addCategory(time, value);
      });
    }

    function showAddItemInput() {
      const time = state.primaryLine[state.selected.timeIndex];
      const category = state.categories[time][state.selected.category];
      showInputBox('Add Item', 'Enter new item:', function(value) {
        google.script.run.withSuccessHandler(function(newItems) {
          state.items = newItems;
          renderViewport();
        }).addItem(category, value);
      });
    }

    function showInputBox(title, prompt, callback) {
      const container = document.getElementById('viewport-container');
      const inputDiv = document.createElement('div');
      inputDiv.className = 'input-box';
      inputDiv.innerHTML = `<strong>${title}</strong><label>${prompt}</label>`;
      const input = document.createElement('input');
      input.type = 'text';
      input.autofocus = true;
      inputDiv.appendChild(input);
      const submitBtn = document.createElement('button');
      submitBtn.textContent = 'Submit';
      submitBtn.onclick = function() {
        if (input.value.trim()) {
          callback(input.value.trim());
        }
      };
      inputDiv.appendChild(submitBtn);
      container.appendChild(inputDiv);
      input.focus();
    }

    function handleSelection(selection) {
        // Pass current state and new selection to Apps Script
        google.script.run.withSuccessHandler(function(newState) {
        state = newState;
        renderViewport();
        }).transformStream(state, selection);
    }



    // --- On Load ---
    window.onload = initViewport;

    // hourGlass: manages line vectors and positions for n-dimensional orthogonal layouts
const hourGlass = {
  // Predefined base vectors for the first two lines (vertical, then horizontal)
  baseVectors: [
    { x: 1, y: 0 },   // Primary (vertical)
    { x: 0, y: -1 }   // Category (horizontal)
  ],
  // Compute the vector for a given depth (line index)
  getVector: function(depth) {
    if (depth < this.baseVectors.length) return this.baseVectors[depth];
    // For 2D, alternate between the two base vectors (for 3D, use cross product)
    // For demonstration, rotate 90 degrees for each new line
    const prev = this.getVector(depth - 1);
    return { x: -prev.y, y: prev.x };
  },
  // Compute the absolute position for an item on a line
  getPosition: function(depth, index, basePos = { x: 200, y: 400 }) {
    let pos = { ...basePos };
    for (let d = 0; d <= depth; d++) {
      const v = this.getVector(d);
      pos.x += v.x * 140 * (d === depth ? index : 0);
      pos.y += v.y * 80 * (d === depth ? index : 0);
    }
    return pos;
  }
};
function enableRelativeNavigation(lineDiv, depth) {
  let isDragging = false, start = null;
  lineDiv.onmousedown = (e) => {
    isDragging = true;
    start = { x: e.clientX, y: e.clientY };
  };
  document.onmousemove = (e) => {
    if (!isDragging) return;
    const dx = e.clientX - start.x, dy = e.clientY - start.y;
    const v = hourGlass.getVector(depth);
    // Project mouse movement onto line vector
    const proj = (dx * v.x + dy * v.y) / Math.sqrt(v.x * v.x + v.y * v.y);
    // Use proj to determine navigation (e.g., proj > threshold => next item)
    // Implement selection logic here
  };
  document.onmouseup = () => { isDragging = false; };
}

  </script>
</body>
</html>
