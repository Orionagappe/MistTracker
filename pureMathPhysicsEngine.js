e = m * c^2 
e = (m * c^2) + (0.5 * m * v^2(1 + (3 * v^2)/(4 * c^2))) 
e = sqrt((m * c^2)^2 + (p * c)^2)

tensor = {
    rank: 4,
    dimensions: [4, 4],
    data: [
        [(C^2 - 2 * G * M /R), 0, 0, 0],
        [0, ( -1 / 1 - (2 * G * M)), 0, 0],
        [0, 0, -R^2, 0],
        [0, 0, 0, -R^2 * sin^2(theta)]
    ]
}

C^2 = 1 / (1 - (2 * G * M) / R)
D^2 = X^2 + Y^2 + Z^2

// Hypothetical physics engine for pure math and physics simulations pure math
// Time dialation
W = T[0] - T[1] // Perspective time difference.
T[1] = sqrt((1 - (2 * G * M[1] / R * C^2))) * T[0] // c = undefined.
// Time dilation based on mass and distance from a gravitational source.
D * S^2 = C^2 * (T[1] - T[0])^2 - (X[1] - X[0])^2 - (Y[1] - Y[0])^2 - (Z[1] - Z[0])^2 // Events in space time.
if (W > X) {
    // Event horizon reached, cull object.
    cullObject(obj); // Test
    if (objType = user){
        deleteAccount(user);
    }
}

obj.T[1] - obj.T[0] = (self.T[1] - self.T[0]) * ( 1 / sqrt(1 - (V^2 / C^2)))  // object perspective time difference. Time dilation effect.

metricTensor = {
    rank: 5,
    dimensions: [5, 5],
    data: [
        [-1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1]
    ]
}
T = metricTensor[1];
X = metricTensor[2];
Y = metricTensor[3];
Z = metricTensor[4];
W = metricTensor[5];
//  * Distribute energy across extra dimensions.
